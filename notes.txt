::todos::
....write gemfile file
....RSpec examples which are clearly named
....write down learnings
.how to fail loudly? -> scrivi mock che ritorna pagina senza lat e lng e la funzione restituisce errore
.se non c'e' html che succede? se non c'e' il css? se non trova lat e lng?
.mock ritorna cose sbagliate -> modifica la funzione per considerare
.testa se lng > 180, o se hai solo un valore

What are the things that are likely to go wrong? Simulate those situations in a few tests.
  1. you _do_ have an internet connection
  2. the website _does_ return you a page and a good status code (what happens if 500?)
  3. the response _does_ have the HTML structure which permits you to apply your CSS selector
  4. the text in the elements you select _does_ contain the latitude and longitude values

Note that a "deviation from a happy path" does not mean that
you have to provide a latitude and longitude return values that are correct and usable regardless.
It's fine to say that "something went wrong" obtaining those values and fail.
But then you need to ensure that you are "failing loudly" and verify it with tests.
And, importantly, that if someone runs your code and the code fails,
it becomes clear to _that particular person_ why the code failed.

5. How can we test the parsing that we perform in a more exact way?
  We know that one of the things that can change with time are the coordinates of the boat
  it will start moving. How do we ensure our parsing logic is correct
  without having the website give us the exact same latitude and longitude values every time we run our tests?

::learnings::

1. There is a lot I need to learn about testing!

2. Net::HTTP and RestClient return different things, both different from regular HTTP requests

3. Catching errors, bad requests and timeouts is frustrating

4. Test the interface, not the implementation (it would bind you to the current implementation)

5. Importing data from an external source makes the initial method NOT a pure function
(and therefore every other method after that)

6. Never rescue from exception, rescue from StandardError

7. When functions are pure and values are easy to inspect and create,
then every function call can be reproduced in isolation.
The impact this has on testing and debugging is hard to overstate.

8. Invoking a pure function means you specify a dependency:
this output value depends on these input values.
But what if you never use the output value?
Because the function can not cause side effects,
it does not matter if it is called or not.
Hence a smart system can be lazy and optimize the call away.
